# 模板

## 函数模板
```c++
template<class 类型参数1, class 类型参数2, … >
返回值类型 模板名 (形参表)
{
    函数体
}
```
C++编译器遵循以下优先顺序:
Step 1: 先找参数完全匹配的普通函数(非由模板实例化而得的函数)
Step 2: 再找参数完全匹配的模板函数
Step 3: 再找实参经过自动类型转换后能够匹配的普通函数
Step 4: 上面的都找不到, 则报错

## 类模板
```c++
template <类型参数表>
class 类模板名
{
    成员函数和成员变量
};
```
在调用类模板时, 指定参数, 由编译系统根据参数提供的数据类型自动产生相应的模板类。

编译器由类模板生成类的过程叫类模板的实例化
• 编译器自动用具体的数据类型
替换类模板中的类型参数, 生成模板类的代码由类模板实例化得到的类叫模板类
• 为类型参数指定的数据类型不同, 得到的模板类不同

类模板的参数声明中可以包括非类型参数
template <class T, int elementsNumber>
• 非类型参数: 用来说明类模板中的属性
• 类型参数: 用来说明类模板中的属性类型, 成员操作的参数类型和返回值类型

- 类模板派生出类模板
- 模板类 (即类模板中类型/非类型参数实例化后的类)
- 派生出类模板
- 普通类派生出类模板
- 模板类派生出普通类

### 类模板特化
泛化模板中的一个特定类型的模板类，特化分为全特化和偏特化。
- 全特化：所有的模板参数特化
- 偏特化
  - 个数偏特化：部分参数特化
  - 范围偏特化：参数作用特化
```c++
//泛化
template <typename T>
class test {
    T data;
}
template <typename T,typename T2>
class test2 {
    T data;
}
//全特化
template<>
class test<int> {
    int data;
}
//参数个数偏特化
template<T>
class test2<T,int> {
    int data;
}
//参数范围偏特化
template<T>
class test<T*> {
    int data;
}
```